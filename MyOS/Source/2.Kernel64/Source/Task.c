#include "Task.h"
#include "Descriptor.h"
#include "Utility.h"

static Scheduler gs_stScheduler;
static TCBPoolManager gs_stTCBPoolManager;

void SetUpTask(TCB* pstTCB, QWORD qwFlags, QWORD qwEntryPointAddress, void* pvStackAddress, QWORD qwStackSize)
{
	MemorySet(pstTCB->stContext.vqRegister, 0, sizeof(pstTCB->stContext.vqRegister));

	pstTCB->stContext.vqRegister[TASK_RSPOFFSET] = (QWORD)pvStackAddress + qwStackSize;
	pstTCB->stContext.vqRegister[TASK_RBPOFFSET] = (QWORD)pvStackAddress + qwStackSize;

	pstTCB->stContext.vqRegister[TASK_CSOFFSET] = GDT_KERNELCODESEGMENT;
	pstTCB->stContext.vqRegister[TASK_DSOFFSET] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[TASK_ESOFFSET] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[TASK_GSOFFSET] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[TASK_SSOFFSET] = GDT_KERNELDATASEGMENT;

	pstTCB->stContext.vqRegister[TASK_RIPOFFSET] = qwEntryPointAddress;

	pstTCB->stContext.vqRegister[TASK_RFLAGSOFFSET] |= 0x0200;//IF 플래그 활성화

	pstTCB->pvStackAddress = pvStackAddress;
	pstTCB->qwStackSize = qwStackSize;
	pstTCB->qwFlags = qwFlags;
}

void InitializeTCBPool()
{
	int i;

	MemorySet(&(gs_stTCBPoolManager), 0, sizeof(gs_stTCBPoolManager));

	//태스크 풀의 어드레스를 지정하고 초기화
	gs_stTCBPoolManager.pstStartAddress = (TCB*)TASK_TCBPOOLADDRESS;
	MemorySet(TASK_TCBPOOLADDRESS, 0, sizeof(TCB) * TASK_MAXCOUNT);

	//TCB에 ID 할당
	for (i = 0; i < TASK_MAXCOUNT; i++)
	{
		gs_stTCBPoolManager.pstStartAddress[i].stLink.qwID = i;
	}

	//TCB의 최대 개수와 할당된 횟수를 초기화
	gs_stTCBPoolManager.iMaxCount = TASK_MAXCOUNT;
	gs_stTCBPoolManager.iAllocatedCount = 1;
}

//TCB를 할당받음
TCB* AllocateTCB()
{
	TCB* pstEmptyTCB;
	int i;

	if (gs_stTCBPoolManager.iUseCount == gs_stTCBPoolManager.iMaxCount)
	{
		return NULL;
	}

	for (i = 0; i < gs_stTCBPoolManager.iMaxCount; i++)
	{
		//ID의 상위 32비트가 0이면 할당되지 않은 TCB
		if ((gs_stTCBPoolManager.pstStartAddress[i].stLink.qwID >> 32) == 0)
		{
			pstEmptyTCB = &(gs_stTCBPoolManager.pstStartAddress[i]);
			break;
		}
	}

	//상위 32비트를 0이 아닌 값으로 설정해서 할당된 TCB로 설정
	pstEmptyTCB->stLink.qwID = ((QWORD)gs_stTCBPoolManager.iAllocatedCount << 32) | i;
	gs_stTCBPoolManager.iUseCount++;
	gs_stTCBPoolManager.iAllocatedCount++;
	if (gs_stTCBPoolManager.iAllocatedCount == 0)
	{
		gs_stTCBPoolManager.iAllocatedCount = 1;
	}

	return pstEmptyTCB;
}

//TCB를 해제함
void FreeTCB(QWORD qwID)
{
	int i;

	//태스크 ID의 하위 32비트가 인덱스 역할을 함
	i = qwID & 0xFFFFFFFF;

	//TCB를 초기화하고 ID 설정
	MemorySet(&(gs_stTCBPoolManager.pstStartAddress[i].stContext), 0, sizeof(CONTEXT));
	gs_stTCBPoolManager.pstStartAddress[i].stLink.qwID = i;

	gs_stTCBPoolManager.iUseCount--;
}

//태스크를 생성
//태스크 ID에 따라서 스택 풀에서 스택 자동 할당
TCB* CreateTask(QWORD qwFlags, QWORD qwEntryPointAddress)
{
	TCB* pstTask;
	void* pvStackAddress;

	pstTask = AllocateTCB();
	if (pstTask == NULL)
	{
		return NULL;
	}

	//태스크 ID로 스택 어드레스 계산, 하위 32비트가 스택 풀의 오프셋 역할 수행
	pvStackAddress = (void*)(TASK_STACKPOOLADDRESS + (TASK_STACKSIZE * (pstTask->stLink.qwID & 0xFFFFFFFF)));

	SetUpTask(pstTask, qwFlags, qwEntryPointAddress, pvStackAddress, TASK_STACKSIZE);
	AddTaskToReadyList(pstTask);

	return pstTask;
}


//스케줄러 관련
//TCB풀과 init 태스크도 같이 초기화
void InitializeScheduler()
{
	//태스크 풀 초기화
	InitializeTCBPool();

	//준비 리스트 초기화
	InitializeList(&(gs_stScheduler.stReadyList));

	//TCB를 할당받아 실행 중인 태스크로 설정하여, 부팅을 수행한 태스크를 저장할 TCB를 준비
	gs_stScheduler.pstRunningTask = AllocateTCB();
}

//현재 수행 중인 태스크를 설정
void SetRunningTask(TCB* pstTask)
{
	gs_stScheduler.pstRunningTask = pstTask;
}

//현재 수행 중인 태스크를 반환
TCB* GetRunningTask()
{
	return gs_stScheduler.pstRunningTask;
}

//태스크 리스트에서 다음으로 실행할 태스크를 얻음
TCB* GetNextTaskToRun()
{
	if (GetListCount(&(gs_stScheduler.stReadyList)) == 0)
	{
		return NULL;
	}

	return (TCB*)RemoveListFromHeader(&(gs_stScheduler.stReadyList));
}

void AddTaskToReadyList(TCB* pstTask)
{
	AddListToTail(&(gs_stScheduler.stReadyList), pstTask);
}

//다른 태스크를 찾아서 전환
//인터럽트나 예외가 발생했을 때 호출하면 안됨
void Schedule()
{
	TCB* pstRunningTask;
	TCB* pstNextTask;
	BOOL bPreviousFlag;

	//전환할 태스크가 있어야 함
	if (GetListCount(&(gs_stScheduler.stReadyList)) == 0)
	{
		return;
	}

	//전환하는 도중 인터럽트가 발생하여 태스크 전환이 또 일어나면 곤란하므로
	//전환하는 동안 인터럽트가 발생하지 못하도록 설정
	bPreviousFlag = SetInterruptFlag(FALSE);
	//실행할 다음 태스크를 얻음
	pstNextTask = GetNextTaskToRun();

	if (pstNextTask == NULL)
	{
		SetInterruptFlag(bPreviousFlag);
		return;
	}

	pstRunningTask = gs_stScheduler.pstRunningTask;
	AddTaskToReadyList(pstRunningTask);

	//프로세서 사용 시간을 업데이트
	gs_stScheduler.iProcessorTime = TASK_PROCESSORTIME;

	//다음 태스크를 현재 수행 중인 태스크로 설정한 후 콘텍스트 전환
	gs_stScheduler.pstRunningTask = pstNextTask;
	SwitchContext(&(pstRunningTask->stContext), &(pstNextTask->stContext));

	SetInterruptFlag(bPreviousFlag);
}

//인터럽트가 발생했을 때, 다른 태스크를 찾아 전환
//반드시 인터럽트나 예외가 발생했을 때 호출해야 함
BOOL ScheduleInInterrupt()
{
	TCB* pstRunningTask;
	TCB* pstNextTask;

	char* pcContextAddress;

	//전환할 태스크가 없으면 종료
	pstNextTask = GetNextTaskToRun();
	if (pstNextTask == NULL)
	{
		return FALSE;
	}

	//태스크 전환 처리
	//인터럽트 핸들러에서 저장한 콘텍스트를 다른 콘텍스트로 덮어쓰는 방법으로 처리
	pcContextAddress = (char*)IST_STARTADDRESS + IST_SIZE - sizeof(CONTEXT);

	//현재 태스크를 얻어서 IST에 있는 콘텍스트를 복사하고, 현재 태스크를 준비 리스트로 옮김
	pstRunningTask = gs_stScheduler.pstRunningTask;
	MemoryCopy(&(pstRunningTask->stContext), pcContextAddress, sizeof(CONTEXT));
	AddTaskToReadyList(pstRunningTask);

	//전환해서 실행할 태스크를 Running Task로 설정하고 콘텍스트를 IST에 복사해서
	//자동으로 태스크 전환이 일어나도록 함
	gs_stScheduler.pstRunningTask = pstNextTask;
	MemoryCopy(pcContextAddress, &(pstNextTask->stContext), sizeof(CONTEXT));

	//프로세서 사용 시간을 업데이트
	gs_stScheduler.pstRunningTask = TASK_PROCESSORTIME;
	return TRUE;
}

//프로세서를 사용할수 있는 시간을 하나 줄임
void DecreaseProcessorTime()
{
	if (gs_stScheduler.iProcessorTime > 0)
	{
		gs_stScheduler.iProcessorTime--;
	}
}

//프로세서를 사용할 수 있는 시간이 다 되었는지 여부를 반환
BOOL IsProcessorTimeExpired()
{
	if (gs_stScheduler.iProcessorTime <= 0)
	{
		return TRUE;
	}
	return FALSE;
}